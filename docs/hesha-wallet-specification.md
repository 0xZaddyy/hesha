# Hesha Wallet Technical Specification

**Version**: 1.0  
**Status**: Definitive  
**Security Level**: Critical  
**Author**: Bernard Parah

---

## 1. Overview and Security Model

### 1.0 Proxy Number Format

**Important**: Hesha proxy numbers use a unified format based on country codes:
- Format: `+{country_code}00{remaining_digits}`
- The `00` pattern identifies it as a proxy number
- Examples:
  - US/Canada: `+10012345678` (country code 1)
  - UK: `+440012345678` (country code 44)
  - Ghana: `+23300549115753` (country code 233)
- Length varies: 8-10 digits after "00" depending on country code length
- There is NO distinction between "global" and "local" formats

### 1.1 Wallet vs Issuer Separation

**Critical Architecture Distinction**:
```
Wallet (This Spec)                    Issuer (Separate Service)
------------------                    ------------------------
• Generates user keypairs             • Verifies phone ownership
• Stores private keys                 • Generates proxy numbers
• Manages attestations                • Signs attestations
• Signs verification challenges       • Has own Ed25519 keypair
• User-controlled software            • Service provider

NEVER: Wallet should never send private keys to issuer
NEVER: Issuer should never generate user keys
NEVER: Same component should not do both roles
```

### 1.2 Design Principles

**Inclusive Security**: Security features that work for everyone, not just those with latest devices.

**Platform Diversity**: Equal support for:
- Web browsers
- Desktop applications  
- Mobile apps
- Command-line tools
- Browser extensions

### 1.3 Threat Model

The wallet defends against:
- **Remote attackers** attempting to steal keys or forge signatures
- **Malicious services** attempting replay or confusion attacks
- **Compromised issuers** attempting to track users
- **Network adversaries** performing MITM attacks

### 1.4 Security Guarantees

The wallet provides:
- **Cryptographic non-repudiation** of user approvals
- **Forward secrecy** for compromised devices
- **Unlinkability** between verifications
- **Attestation integrity** verification

---

## 2. Cryptographic Foundations

### 2.1 Key Generation

**Algorithm**: Ed25519 as specified in RFC 8032 (PureEdDSA)

**Key Generation Responsibility**:
```
⚠️ CRITICAL: User keys are ALWAYS generated by the wallet, NEVER by issuers
- Wallet generates Ed25519 keypair locally
- Wallet sends ONLY the public key to issuer
- Private key NEVER leaves the wallet
- This ensures user sovereignty and security
```

**Entropy Requirements**:
```
- Source: Platform secure random
- Minimum entropy: 256 bits
- Use cryptographically secure RNG
```

**Key Derivation Process**:
```
1. seed = secure_random(32 bytes)
2. private_key = seed  // In Ed25519, the 32-byte seed is the "private key"
3. public_key = Ed25519_derive_public(seed)
   // Library internally: 
   // - expanded = SHA512(seed)
   // - scalar = expanded[0:32] with clamping
   // - public_key = scalar * basepoint
4. Verify: Ed25519_sign_verify(test_message, private_key) succeeds
5. Store private_key encrypted, send public_key to issuer

Note: Most Ed25519 libraries (libsodium, ed25519-dalek) accept the 
32-byte seed as the "private key" and handle expansion internally.
```

**Public Key Encoding**:
When transmitting public keys (to issuers or in attestations):
- Format: base64url encoding (RFC 4648, Section 5)
- No padding characters
- Length: 32 bytes raw = 43-44 characters base64url
- Example: `MCowBQYDK2VwAyEAa7bsa2eI7T6w9P6KVJdLvmSGq2uPmTqz2R0RBAl6R2E`

### 2.2 Secure Storage Architecture

**Storage Requirements**:
```
- Private keys must be encrypted at rest
- Use platform-appropriate secure storage when available
- Support password-based encryption as baseline
```

**Storage Format**:
```
// Encrypted storage structure
{
  "encrypted_keys": "encrypted blob",
  "encryption_metadata": "implementation specific"
}
```

**Key Storage Format**:
```
{
  "version": 1,
  "key_id": "uuid_v4",
  "algorithm": "Ed25519-RFC8032",
  "storage_level": "secure_enclave|keystore|encrypted",
  "created_at": epoch_ms,
  "checksum": "sha256:hex"
}
```

### 2.3 Memory Security

**Key Handling**:
```
- Minimize key lifetime in memory
- Clear sensitive data after use when possible
- Use secure coding practices for the implementation language
```

---

## 3. Attestation Management

### 3.1 Attestation Issuance Flow

**Wallet's Role in Getting Attestations**:
```
1. User initiates: "Get proxy number" in wallet
2. Wallet generates Ed25519 keypair locally
3. Wallet connects to chosen issuer
4. Wallet sends to issuer:
   {
     "phone_number": "+1234567890",
     "user_pubkey": "base64url_ed25519_pubkey",  // NO private key!
     "scope": "1"  // country code
   }
5. Issuer verifies phone ownership (SMS/call)
6. Issuer generates proxy number and attestation
7. Wallet receives and stores:
   - Attestation JWT (signed by issuer)
   - Proxy number
   - Keeps private key encrypted locally
```

### 3.2 Attestation Validation

**Required Validations**:
```
1. JWT Structure:
   - Valid base64url encoding
   - Three segments (header.payload.signature)
   - Valid JSON in header/payload

2. Signature Verification:
   - Extract issuer from payload
   - Fetch issuer public key via HTTPS
   - Verify Ed25519 signature
   - Check signature algorithm matches header

3. Payload Validation:
   - exp > current_time
   - iat < current_time  
   - iat < exp
   - proxy_number matches format: +{country_code}00{digits}
   - user_pubkey is valid Ed25519 point

4. Binding Verification:
   - Recompute binding_proof if possible
   - Verify user_pubkey matches stored key
```

### 3.3 Storage Format

**Flexible Storage Options**:
```
1. Encrypted JSON files (works everywhere)
2. Browser LocalStorage (web wallets)
3. SQLite database (desktop/mobile)
4. IndexedDB (web applications)
5. Platform keychains (when available)

Core requirement: Encrypted at rest, format is flexible
```

**Minimal Storage Structure**:
```json
{
  "version": 1,
  "attestations": {
    "+10012345678": {  // US proxy number example
      "jwt": "eyJ0eXAiOiJKV1Q...",
      "private_key_encrypted": "base64...",
      "metadata": {
        "issuer": "example.com",
        "expires_at": 1751536000,
        "country_code": "1",
        "created_at": 1720000000
      }
    }
  }
}
```

---

## 4. Verification Protocol

### 4.0 Verification Flow Overview

**Complete Wallet Verification Flow**:
```
1. Service creates verification challenge for proxy number
2. User scans QR/clicks link with wallet
3. Wallet finds matching attestation by proxy number
4. Wallet shows approval UI: "Service X wants to verify your number"
5. User approves → Wallet signs challenge with user's private key
6. Wallet sends: attestation JWT + signed challenge response
7. Service verifies both signatures (issuer's and user's)
```

### 4.1 Verification Input Methods

**Multiple Input Methods** (for accessibility):
```
1. QR Code Scanning (mobile-friendly)
2. Copy/Paste URL (desktop-friendly)
3. Deep Links (app-to-app)
4. Manual Entry (fallback)

Format: hesha://verify?v=1&data=<base64url_encoded_payload>
```

**Payload Structure**:
```json
{
  "version": 1,
  "proxy_number": "+10012345678",  // Example US proxy number
  "service": {
    "id": "app.example.com",
    "name": "Example App",
    "icon_hash": "sha256:..."  // Prevent UI spoofing
  },
  "challenge": {
    "nonce": "hex(32_bytes)",
    "created_at": epoch_ms,
    "expires_at": epoch_ms
  },
  "verification_id": "uuid_v4",
  "callback": {
    "url": "https://app.example.com/callback",
    "deep_link": "app://hesha/return"
  }
}
```

**Validation Requirements**:
```
1. Version compatibility check
2. Timestamp validation (±5 minutes)
3. Nonce uniqueness (24-hour window)
4. URL validation (HTTPS only, no redirects)
5. Proxy number exists in wallet
6. Service signature verification (optional)
```

### 4.2 Challenge-Response Protocol

**Nonce Generation**:
```
nonce = secure_random(32 bytes)
hex_nonce = hex_encode(nonce)
```

**Context Hash Construction**:
```
context_data = {
  "service_id": string,
  "challenge_nonce": string,
  "response_nonce": string,  
  "timestamp": number,
  "verification_id": string
}
context_bytes = canonical_json(context_data)
context_hash = "sha256:" + hex(sha256(context_bytes))
```

**Signature Generation**:
```
1. Construct challenge response object
2. Create canonical JSON representation
3. UTF-8 encode to bytes
4. Sign with Ed25519: signature = Ed25519_sign(message, private_key)
5. Encode signature as hex
```

**Response Construction**:
```json
{
  "version": 1,
  "verification_id": "from_request",
  "proxy_number": "+10012345678",  // Matches the attestation
  "attestation_jwt": "stored_jwt",
  "challenge_response": {
    "service_id": "from_request",
    "challenge_nonce": "from_request",
    "response_nonce": "generated_hex",
    "timestamp": epoch_ms,
    "context_hash": "sha256:..."
  },
  "user_signature": "hex_encoded_ed25519_signature",
  "wallet_info": {
    "version": "1.0.0",
    "platform": "ios|android|desktop"
  }
}
```

### 4.3 Deep Link Security

**Secure Deep Link Format**:
```
app://hesha/verify?token=<signed_jwt>

Where token contains:
{
  "action": "verify_response",
  "verification_id": "uuid",
  "status": "completed|cancelled|error",
  "timestamp": epoch_ms,
  "signature": "wallet_signature"
}
```

**Deep Link Validation**:
```
1. Verify JWT signature with wallet's key
2. Check timestamp (±60 seconds)
3. Validate verification_id matches pending
4. Ensure single-use (mark as consumed)
5. Verify source app identity
```

**Platform-Specific Considerations**:
```
iOS:
- Universal Links recommended for better UX
- Validate source when possible

Android:
- App Links recommended for security
- Standard deep links as fallback

Desktop/Web:
- URL protocol handlers
- Browser extension support
```

---

  ## 5. Network Security

  ### 5.1 Key Discovery

  **Issuer Key Discovery**:
  1. Fetch public key from /.well-known/hesha/pubkey.json
  2. Security requirements:
    - Production: HTTPS only
    - Development: HTTP allowed for localhost/127.0.0.1/::1
  3. Validate JSON structure and Ed25519 key format
  4. Cache with appropriate TTL

  ### 5.2 Callback Security

  **Verification Callback**:
  1. URL validation:
    - Production: HTTPS only
    - Development: HTTP allowed for localhost
  2. No redirect following (security boundary)
  3. Timeout: 30 seconds
  4. Retry: 3 attempts with exponential backoff

  **HTTP Headers**:
  POST /callback HTTP/1.1
  Host: app.example.com
  Content-Type: application/json
  X-Hesha-Version: 1.0
  X-Request-ID: <uuid>

  **Callback Payload**:
  ```json
  {
    "verification_id": "chatapp_verify_12345",
    "proxy_number": "+10012345678",
    "attestation_jwt": "eyJhbGci...",
    "challenge_response": {
      "service_id": "chatapp.com",
      "challenge_nonce": "a1b2c3d4e5f6",
      "response_nonce": "x9y8z7w6v5u4",
      "timestamp": 1720000000,
      "context_hash": "sha256:..."
    },
    "user_signature": "5d4c3b2a..."
  }
  ```

  **Response Validation**:
  - Status code: 200-299 only
  - Content-Type: application/json
  - Body size limit: 10KB
  - JSON schema validation

---

## 6. Anti-Replay and Anti-Confusion

### 6.1 Nonce Management

```rust
struct NonceManager {
    // Sliding window of 24 hours
    window_start: u64,
    used_nonces: HashMap<String, u64>,
    
    fn validate_nonce(&mut self, nonce: &str) -> Result<(), NonceError> {
        // Clean old nonces
        self.clean_expired();
        
        // Check if used
        if self.used_nonces.contains_key(nonce) {
            return Err(NonceError::AlreadyUsed);
        }
        
        // Mark as used
        self.used_nonces.insert(nonce.to_string(), current_time());
        Ok(())
    }
}
```

### 6.2 Service Binding

Each signature MUST be bound to:
- Specific service_id
- Specific challenge_nonce  
- Specific timestamp (±5 minutes)
- Specific verification_id

---

## 7. Privacy Protections

### 7.1 Unlinkability

- Different response_nonce for each verification
- No correlation between verifications
- No persistent identifiers shared
- Timestamps rounded to nearest minute

### 7.2 Metadata Minimization

- No analytics in verification flow
- No tracking pixels
- No third-party libraries
- Minimal logging (security events only)

---

## 8. Failure Modes and Recovery

### 8.1 Key Compromise

**Detection**:
- Unexpected verification attempts
- Geographic anomalies
- Timing pattern changes

**Response**:
- Immediate key revocation
- Notification to user
- Re-attestation required

### 8.2 Wallet Recovery

**Backup Format**:
```json
{
  "version": 1,
  "encrypted_data": "base64...",
  "encryption": {
    "algorithm": "AES-256-GCM",
    "kdf": "argon2id",
    "salt": "base64...",
    "params": {
      "memory": 65536,
      "iterations": 3,
      "parallelism": 1
    }
  },
  "checksum": "sha256:..."
}
```

---

## 9. Implementation Requirements

### 9.1 Universal Security Requirements

**Minimum Requirements (All Platforms)**:
1. **Secure random number generation** (platform CSPRNG)
2. **Encrypted storage** (password-protected)
3. **HTTPS only** for network requests
4. **Input validation** on all user data

**Optional Enhancements**:
- Hardware key storage (when available)
- Biometric unlock (convenience feature)
- Certificate pinning (for high-security deployments)

### 9.2 Cryptographic Libraries

**Library Requirements**:
- Use established cryptographic libraries
- Ed25519 signature support required
- SHA-256 hashing required
- Secure random number generation required

---

## 10. Security Best Practices

### 10.1 Open Source Security

- Encourage community security reviews
- Welcome responsible disclosure
- Maintain public security policy
- Transparent incident response

### 10.2 Privacy Considerations

- Minimize data collection
- User consent for all operations
- Data portability support
- Right to deletion

---

**This specification prioritizes security while respecting user freedom. Implementations are encouraged to undergo security review before deployment.**

*End of Specification*